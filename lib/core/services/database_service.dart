/* import 'package:flutter/material.dart';
import 'package:sqflite/sqflite.dart';
// ignore: depend_on_referenced_packages
import 'package:path/path.dart';

/// A singleton class for managing SQLite database operations in a Flutter application.
///
/// This class provides a centralized and thread-safe way to interact with a SQLite database,
/// handling database initialization, schema migrations, and common CRUD operations.  It also
/// addresses a common issue where developers might have an 'id' field in their model
/// that conflicts with the 'id' column automatically generated by SQLite.
///
///
/// // USE:
/// ```
/// // 1. Get the Singleton instance
/// final dbService = DatabaseService();
///
/// // 2. Create a table (if necessary)
/// await dbService. createTable(
/// 'users',
/// {
/// 'name': 'TEXT NOT NULL',
/// 'email': 'TEXT UNIQUE NOT NULL',
/// 'age': 'INTEGER',
/// },
/// );
///
/// // 3. Insert data
/// int newUserId = await dbService. insert(
/// 'users',
/// {'name': 'John Doe', 'email': 'john@example.com', 'age': 30},
/// );
/// print('New user ID: $newUserId');
///
/// await dbService.insertMultiple(
/// 'products',
/// [
/// {'name': 'Laptop', 'price': 1200.00},
/// {'name': 'Mouse', 'price': 25.00},
/// ],
/// );
///
/// // 4. List data
/// List<Map<String, dynamic>> users = await dbService.list('users');
/// print('List of users: $users');
///
/// // 5. Get an item by ID
/// Map<String, dynamic>? user = await dbService.getItemById('users', 1);
/// print('User with ID 1: $user');
///
/// // 6. Update data
/// int updatedRows = await dbService. update(
/// 'users',
/// {'id': 1, 'name': 'Juan Carlos', 'age': 31},
/// );
/// print('Updated rows: $updatedrows');
///
/// // 7. Delete data
/// int deletedRows = await dbService. delete('users', 1);
/// print('Deleted rows: $deletedrows');
///
/// // 8. Perform custom queries
/// List<Map<String, dynamic>> usuariosMayoresDe25 = await dbService. query(
/// 'usuarios',
/// 'SELECT * FROM usuarios WHERE edad > ?',
/// [25],
/// );
/// print('Users over 25: $usuariosMayoresDe25');
/// ```
///
/// Full example:
/// ```
/// void main() async {
///  // Get the Singleton instance of the DatabaseService.  This is the entry point for using the class.
///  final dbService = DatabaseService();
///  final db = await dbService.database;  //  Get the database instance.
///
///  // Create a table (example: 'my_table').  This should be done once for each table in your application.
///  //  The schema defines the columns and their data types.
///  await dbService.createTable(
///    'my_table',
///    {
///      'name': 'TEXT NOT NULL',      //  A text column that cannot be null.
///      'other_column': 'INTEGER', //  An integer column.
///    },
///  );
///
///  // Insert some test data (version 1 of the database schema).
///  await dbService.insert('my_table', {'name': 'Record 1', 'other_column': 10});
///  await dbService.insert('my_table', {'name': 'Record 2', 'other_column': 20});
///
///  print("Data in Version 1:");
///  print(await dbService.list('my_table')); //  List the data in the table.
///
///  // Simulate a schema change (this would typically happen in a new version of your app).
///  // 1.  Increment the `_databaseVersion` constant in the DatabaseService class (see above).
///  // 2.  Add a new `Migration` object to the `_migrations` list (see above).
///
///  // Execute an operation that triggers the database upgrade.  The migration will be executed
///  // automatically before this operation is performed.  In this case, we're just listing the table.
///  print("Data in Version 2:");
///  print(await dbService.list('my_table'));
///
///  // Insert a new record after the migration.  Note that we're now including the 'new_column'.
///  await dbService.insert('my_table', {'name': 'Record 3', 'other_column': 30, 'new_column': 'New Value'});
///  print("Data after insertion in Version 2:");
///  print(await dbService.list('my_table'));
///
///  // Example of using the 'query' method for a custom SQL query.
///  List<Map<String, dynamic>> results = await dbService.query('my_table', 'SELECT * FROM my_table WHERE name = ?', ['Record 1']);
///  print("Query result: $results");
///
///  // Example of getting an item by its ID.
///  Map<String, dynamic>? item1 = await dbService.getItemById('my_table', 1);
///  print("Item with id 1: $item1");
///
///  // Example of updating a record.
///  await dbService.update('my_table', {'id': 1, 'name': 'Record 1 Modified'});
///  print("Data after update: ${await dbService.list('my_table')}");
///
///  // Example of deleting a record.
///  await dbService.delete('my_table', 2);
///  print("Data after deletion: ${await dbService.list('my_table')}");
///}
///```
///
class DatabaseService {
  /// Singleton instance of the class
  static DatabaseService? _instance;

  /// Database instance
  static Database? _database;

  /// Current database version.  Increment this whenever the database schema changes.
  ///  Important:  Increment on schema changes!
  static const int _databaseVersion = 1;

  /// Private constructor to prevent external instantiation.  This is part of the Singleton pattern.
  DatabaseService._internal();

  /// Factory method to get the Singleton instance.
  /// This ensures only one instance of DatabaseService exists.
  factory DatabaseService() {
    return _instance ??= DatabaseService._internal();
  }

  /// Asynchronous getter for the database instance.
  /// This is the primary way to access the database.
  Future<Database> get database async {
    // Return the existing database if already initialized.
    if (_database != null) return _database!;

    // Initialize the database if it hasn't been yet.
    _database = await _initDatabase();
    return _database!;
  }

  /// Gets the full path to the database file.
  ///
  /// This method constructs the complete file path where the SQLite database will be stored.
  /// It uses the `getDatabasesPath()` method from the `sqflite` package to get the appropriate
  /// directory for storing database files on the platform.
  Future<String> get fullPath async {
    //  Name your database file here.
    const String databaseName = 'app_database.db';

    //  Gets the platform-specific database directory.
    final String path = await getDatabasesPath();

    //  Combines the directory and filename.
    return join(path, databaseName);
  }

  /// Initializes the database.
  ///
  /// This method opens or creates the SQLite database file.  It sets up the database version,
  /// and provides callbacks for database creation (`onCreate`) and schema upgrades (`onUpgrade`).
  Future<Database> _initDatabase() async {
    final String path = await fullPath;
    debugPrint('DatabaseService, fullPath: $path');

    return await openDatabase(
      path,
      // Use the defined version constant.
      version: _databaseVersion,

      // Callback for when the database is first created.
      onCreate: _onCreate,

      // Callback for when the database version is upgraded.
      onUpgrade: _onUpgrade,
    );
  }

  ///  Called when the database is created for the first time.
  ///
  ///  This method is a callback function that is executed by the `sqflite` package
  ///  when the database file does not exist and needs to be created.  It's typically
  ///  used to create the initial tables and set up the database schema.  In this
  ///  implementation, we leave it empty because table creation is handled either
  ///  dynamically via `createTable` or through migrations in `_onUpgrade`.  This
  ///  provides more flexibility and centralized control over schema management.
  ///
  ///  @param db The database instance.
  ///  @param version The version of the database being created.
  Future<void> _onCreate(Database db, int version) async {
    //  No initial table creation here.  See _onUpgrade and createTable.
  }

  ///  Called when the database needs to be upgraded.
  ///
  ///  This method is a callback function that is executed by the `sqflite` package
  ///  when the database version on disk is older than the `version` specified in the
  ///  `openDatabase` call.  It's used to perform schema migrations, such as adding
  ///  new tables, modifying existing tables, or deleting tables.
  ///
  ///  This implementation iterates through a list of `Migration` objects
  ///  (`_migrations`) and executes the `migrate` function of each migration whose
  ///  version is greater than the `oldVersion` and less than or equal to the `newVersion`.
  ///  This allows for incremental schema upgrades.
  ///
  ///  @param db The database instance.
  ///  @param oldVersion The previous version of the database.
  ///  @param newVersion The new version of the database.
  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    // Execute migrations as needed.  See the _migrations list.
    for (final migration in _migrations) {
      if (migration.version > oldVersion && migration.version <= newVersion) {
        await migration.migrate(db);
      }
    }
  }

  ///  Creates a table in the database dynamically.
  ///
  ///  This method allows you to create tables at runtime, specifying the table name
  ///  and the schema (column names and data types).  It automatically adds an
  ///  auto-incrementing primary key column named 'id'.
  ///
  ///  @param tableName The name of the table to create.
  ///  @param schema A map where keys are column names and values are their data types (e.g., {'name': 'TEXT NOT NULL', 'age': 'INTEGER'}).
  ///  @throws `sqflite.SqfliteException` If there is an error executing the SQL statement.
  Future<void> createTable(String tableName, Map<String, String> schema) async {
    final Database db = await database;
    String createTableStatement = 'CREATE TABLE IF NOT EXISTS $tableName (';
    // Ensures unique ID for each record.
    createTableStatement += 'id INTEGER PRIMARY KEY AUTOINCREMENT, ';

    schema.forEach((columnName, dataType) {
      // Add each column definition.
      createTableStatement += '$columnName $dataType, ';
    });

    // Remove the trailing comma and space.
    createTableStatement =
        createTableStatement.substring(0, createTableStatement.length - 2);

    // Close the CREATE TABLE statement.
    createTableStatement += ')';

    // Execute the SQL statement.
    await db.execute(createTableStatement);
  }

  ///  Inserts a record into a table.
  ///
  ///  This method inserts a new row into the specified table using the provided data.
  ///  It handles a potential conflict where the provided `data` map might contain an 'id' key,
  ///  which would conflict with the auto-generated 'id' column in the database.  To resolve this,
  ///  it renames the provided 'id' key to 'idModel' before inserting the data.
  ///
  ///  @param tableName The name of the table to insert into.
  ///  @param data A map where keys are column names and values are the data to insert.
  ///  @returns The ID of the newly inserted record.
  ///  @throws `sqflite.SqfliteException` If there is an error during the insertion.
  Future<int> insert(String tableName, Map<String, dynamic> data) async {
    final Database db = await database;
    //  Create a copy of the data to avoid modifying the original map.
    Map<String, dynamic> dataToInsert = Map.from(data);

    //  If the data contains an 'id', rename it to 'idModel' for the database.
    if (dataToInsert.containsKey('id')) {
      dataToInsert['idModel'] = dataToInsert['id'];

      // Remove the original 'id' key.
      dataToInsert.remove('id');
    }

    // Perform the insertion.
    return await db.insert(tableName, dataToInsert);
  }

  /// Inserts multiple records into a table efficiently.
  ///
  /// This method inserts multiple rows into the specified table using a batch operation.
  /// Like the `insert` method, it handles potential 'id' key conflicts by renaming them to
  /// 'idModel' before inserting the data.  Using a batch is significantly faster than
  /// inserting records one at a time.
  ///
  /// @param tableName The name of the table to insert into.
  /// @param dataList A list of maps, where each map represents a row to insert.
  /// @throws `sqflite.SqfliteException` If there is an error during the batch operation.
  Future<void> insertMultiple(
      String tableName, List<Map<String, dynamic>> dataList) async {
    final Database db = await database;

    // Begin a new batch operation.
    final Batch batch = db.batch();

    for (final data in dataList) {
      // Apply the same logic as the 'insert' method to handle 'id' / 'idModel'.
      Map<String, dynamic> dataToInsert = Map.from(data);

      if (dataToInsert.containsKey('id')) {
        dataToInsert['idModel'] = dataToInsert['id'];
        dataToInsert.remove('id');
      }

      // Add the insert operation to the batch.
      batch.insert(tableName, dataToInsert);
    }

    // Commit the batch, executing all operations at once.
    await batch.commit();
  }

  /// Updates a record in a table.
  ///
  /// This method updates an existing row in the specified table.  It requires the 'id'
  /// of the record to update.  It handles a potential conflict where the provided `data`
  /// map might contain an 'idModel' key (from a previous insert where the user provided
  /// an ID).  If 'idModel' is present, it's renamed to 'id' before the update.
  ///
  /// @param tableName The name of the table to update.
  /// @param data A map where keys are column names and values are the updated data.  Must include the 'id' of the record to update.
  /// @returns The number of rows that were updated.
  /// @throws `sqflite.SqfliteException` If there is an error during the update.
  /// @throws `ArgumentError` If the `data` map does not contain an 'id' or 'idModel' key.
  Future<int> update(String tableName, Map<String, dynamic> data) async {
    final Database db = await database;
    //  Handle the potential 'idModel' key from user-provided IDs.
    Map<String, dynamic> dataToUpdate = Map.from(data);

    if (dataToUpdate.containsKey('idModel')) {
      dataToUpdate['id'] = dataToUpdate['idModel']; // Rename 'idModel' to 'id'.
      dataToUpdate.remove('idModel');
    }

    //  Ensure that we have an 'id' key for the WHERE clause.
    if (!dataToUpdate.containsKey('id')) {
      throw ArgumentError(
          'The data map must contain an "id" or "idModel" key for the update.');
    }
    return await db.update(
      tableName,
      dataToUpdate,
      where: 'id = ?', //  Use a WHERE clause to update the correct record.
      whereArgs: [
        dataToUpdate['id']
      ], //  Use whereArgs for safe parameter binding.
    );
  }

  /// Deletes a record from a table by its ID.
  ///
  /// This method deletes the row with the specified 'id' from the given table.
  ///
  /// @param tableName The name of the table to delete from.
  /// @param id The ID of the record to delete.
  /// @returns The number of rows that were deleted.
  /// @throws `sqflite.SqfliteException` If there is an error during the deletion.
  Future<int> delete(String tableName, int id) async {
    final Database db = await database;
    return await db.delete(
      tableName,
      where: 'id = ?', //  Use a WHERE clause to delete the correct record.
      whereArgs: [id], //  Use whereArgs for safe parameter binding.
    );
  }

  /// Lists all records from a table.
  ///
  /// This method retrieves all rows from the specified table.  It also handles the potential
  /// presence of the 'idModel' key in the result set (from a previous insert where the user
  /// provided an ID).  If 'idModel' is found, it's renamed to 'id' in the returned data.
  ///
  /// @param tableName The name of the table to query.
  /// @returns A list of maps, where each map represents a row in the table.  Returns an empty list if the table is empty.
  /// @throws `sqflite.SqfliteException` If there is an error during the query.
  Future<List<Map<String, dynamic>>> list(String tableName) async {
    final Database db = await database;
    final List<Map<String, dynamic>> results = await db.query(tableName);
    //  Convert 'idModel' to 'id' in the results, if necessary.
    return results.map((row) {
      if (row.containsKey('idModel')) {
        row['id'] = row['idModel'];
        row.remove('idModel');
      }
      return row;
    }).toList();
  }

  /// Gets a record from a table by its ID.
  ///
  /// This method retrieves the row with the specified 'id' from the given table.
  /// It also handles the potential presence of the 'idModel' key in the result set.
  ///
  /// @param tableName The name of the table to query.
  /// @param id The ID of the record to retrieve.
  /// @returns A map representing the row, or null if no record with the given ID exists.
  /// @throws `sqflite.SqfliteException` If there is an error during the query.
  Future<Map<String, dynamic>?> getItemById(String tableName, int id) async {
    final Database db = await database;
    final List<Map<String, dynamic>> results = await db.query(
      tableName,
      where: 'id = ?', //  Use a WHERE clause to get the correct record.
      whereArgs: [id], //  Use whereArgs for safe parameter binding.
      limit: 1, //  Optimize the query by limiting to 1 result.
    );
    if (results.isNotEmpty) {
      Map<String, dynamic> row = results.first;
      if (row.containsKey('idModel')) {
        row['id'] = row['idModel'];
        row.remove('idModel');
      }
      return row;
    }
    return null; // Return null if no record is found.
  }

  /// Executes a custom SQL query.
  ///
  /// This method allows you to execute arbitrary SQL queries against the database.  It's useful
  /// for complex queries that are not directly supported by the other methods of this class.
  /// It also handles the potential presence of the 'idModel' key in the result set.
  ///
  /// @param tableName The name of the table involved in the query.  This is primarily for context and documentation.
  /// @param sql The SQL query to execute.  Use parameter placeholders ('?') for safe parameter binding.
  /// @param arguments A list of arguments to bind to the parameters in the SQL query.  This prevents SQL injection.
  /// @returns A list of maps, where each map represents a row in the result set.
  /// @throws `sqflite.SqfliteException` If there is an error executing the query.
  Future<List<Map<String, dynamic>>> query(
      String tableName, String sql, List<dynamic>? arguments) async {
    final Database db = await database;
    final List<Map<String, dynamic>> results =
        await db.rawQuery(sql, arguments);
    //  Convert 'idModel' to 'id' in the results, if necessary.
    return results.map((row) {
      if (row.containsKey('idModel')) {
        row['id'] = row['idModel'];
        row.remove('idModel');
      }
      return row;
    }).toList();
  }
}

///  Represents a database migration.
///
///  A migration is a set of SQL statements that are executed to change the database schema
///  from one version to another.  Each migration is associated with a specific version number.
class Migration {
  //  The version of the database schema that this migration updates to.
  final int version;

  //  The function to execute the migration.
  final Future<void> Function(Database db) migrate;

  Migration({required this.version, required this.migrate});
}

///  List of database migrations.
///
///  This list defines the sequence of schema changes that need to be applied to the database
///  as it's upgraded from one version to another.  Migrations are ordered by their `version` number.
///
///  **Important:** Whenever you change the database schema (e.g., add a table, add a column,
///  change a column type), you **must** add a new `Migration` object to this list
///  and **increment** the `_databaseVersion` constant in the `DatabaseService` class.
final List<Migration> _migrations = [
  Migration(
    version: 2, //  This migration updates the database to version 2.
    migrate: (db) async {
      //  Example migration: Add a new column to the 'my_table' table.
      await db.execute(
          'ALTER TABLE my_table ADD COLUMN new_column TEXT DEFAULT "default_value"');

      //  Example migration: Delete a column (requires recreating the table).
      //  SQLite doesn't directly support dropping columns, so we have to:
      //  1. Create a new table with the desired structure.
      await db.execute('''
        CREATE TABLE new_table (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          name TEXT NOT NULL,
          other_column INTEGER,
          new_column TEXT DEFAULT "default_value"
        )
      ''');

      //  2. Copy the data from the old table to the new table.  Make sure to include the new column.
      await db.execute(
          'INSERT INTO new_table (id, name, other_column, new_column) SELECT id, name, other_column, new_column FROM my_table');

      //  3. Delete the old table.
      await db.execute('DROP TABLE my_table');

      //  4. Rename the new table to the name of the old table.
      await db.execute('ALTER TABLE new_table RENAME TO my_table');
    },
  ),
  //  You can add more migrations here for future versions of the database.  For example:
  //  Migration(
  //    version: 3,
  //    migrate: (db) async {
  //      await db.execute('CREATE TABLE another_table (id INTEGER PRIMARY KEY AUTOINCREMENT, data TEXT)');
  //      await db.execute('ALTER TABLE my_table ADD COLUMN another_column INTEGER');
  //    },
  //  ),
];

// ************************************************************************************************
// ************************************************************************************************
// ************************************************************************************************
 */
